# Langchain vs Langgraph

## LangChain
> Langchain이란, LLM(대규모 언어 모델) 기반의 소프트웨어를 개발하는데 사용되는 프레임워크

### LangChain 작동 방식
- LangChain의 핵심은 추상화를 사용하여 LLM 애플리케이션의 프로그래밍을 간소화하는 개발 환경
- 하나 이상의 복잡한 프로세스의 모든 구성 단계를 명명된 구성 요소로 캡슐화함으로써 코드 단순화

### LangChain 기본 프레임워크
- 개발: 랭체인
  * langchain: 애플리케이션의 코그너티브 아키텍처를 구성하는 체인, 에이전트 및 검색 전략
  * langchain-core: 기본 추상화 및 LangChain 표현 언어
  * langchain-community: 서드파티 통합 (langchain-openai, langchain-anthropic 등)
- 테스트: LangSmith를 사용하여 체인을 검사, 모니터링 및 평가
- 배포: LangGraph Cloud를 사용하여 LangGraph 애플리케이션을 프로덕션에 바로 사용할 수 있는 API와 Assistant로 전환
- 랭체인 템플릿(LangChain Templates): 다양한 작업을 위한 쉽게 배포할 수 있는 참조 아키텍처 모음
<img width="839" height="541" alt="image" src="https://github.com/user-attachments/assets/a46e8c91-7a98-4644-ab20-00c2e5bdefde" />

### LangChain의 주요 기능
- 다양한 데이터 소스와의 통합
- 유연한 프롬프팅 및 컨텍스트 관리
- 파인튜닝 및 커스터마이징
- 데이터 반응형 애플리케이션 구축

## LangGraph
> LangGraph란, LangChain을 기반으로 하는 라이브러리

### LangGraph 특징
- 상태 기반 그래프 구조: 애플리케이션의 로직을 노드와 엣지로 구성된 그래프로 표현
- 유연한 상태 관리: 복잡한 상태를 쉽게 정의하고 관리할 수 있음
- 조건부 라우팅: 동적인 의사결정 프로세스 구현 가능
- 체크포인팅: 그래프 실행 상태를 저장하고 복원할 수 있어장기 실행 태스크와 오류 복구에 유용
- 서브그래프 지원: 복잡한 시스템을 모듈화하여 관리할 수 있음

### LangGraph 사용 이유
- 복잡한 로직 구현: 다단계 의사결정 프로세스나 복잡한 워크플로우 쉽게 구현 가능
- 세밀한 제어: 애플리케이션의 각 단계를 정밀하게 제어할 수 있어, 고도로 커스터마이즈된 동작 구현 가능
- 확장성: 서브그래프를 통해 대규모 시스템을 모듈화하여 관리
- 상태 지속성: 체크포인팅을 통해 장기 실행 태스크와 오류 복구 쉽게 구현 가능
- 다중 에이전트 시스템: 여러 AI 에이전트의 상호작용을 효과적으로 모델링할 수 있음

## LangChain vs LangGraph
|특징|LangGraph|LangChain|
|------|---|---|
|주요 목적|복잡한 워크플로우 및 의사결정 프로세스 구현|LLM 통합 및 체인 구성|
|구조|그래프 기반|체인 및 에이전트 기반|
|상태 관리|명시적이고 세밀한 제어|암시적이고 자동화된 관리|
|유연성|높음 (커스텀 로직 쉽게 구현)|중간 (미리 정의된 컴포넌트 중심)|
|학습 곡선|상대적으로 가파름|상대적으로 완만함|
|용도|복잡한 AI 시스템, 다중 에이전트|간단한 LLM 애플리케이션, RAG|
1. 주요 목적
  - LangGraph: 복잡한 워크플로우와 정교한 의사결정 프로세스를 구현하는 데 특화되어, 여러 단계의 처리 과정이나 조건부 로직이 필요한 고급 AI 시스템에 적합
  - LangChain: LLM을 다양한 외부 도구와 쉽게 통합하고, 간단한 체인 구조로 애플리케이션을 구성하는 데 중점을 두어, 빠른 프로토타이핑과 기본적인 LLM 기반 애플리케이션 개발에 유용
2. 구조
  - LangGraph: 그래프 기반 구조를 채택하여 노드와 엣지로 구성된 유연한 워크플로우 만들 수 있음. 이는 복잡한 로직과 다단계 프로세스를 직관적으로 모델링하는 데 도움이 됨.
  - LangChain: 체인과 에이전트 기반 구조를 사용하여, 선형적인 처리 과정이나 미리 정의된 에이전트 패턴을 구현하기 쉬움.
3. 상태 관리:
  - LangGraph: 명시적이고 세밀한 상태 관리 제공. 개발자가 각 단계에서 상태를 직접 제어하고 수정할 수 있어, 복잡한 상태 변화를 정확하게 추적하고 관리 용이
  - LangChain: 상대적으로 암시적이고 자동화된 상태 관리 제공. 개발 과정을 단순화하지만, 세부적인 상태 제어가 필요한 경우 제한적
4. 유연성:
  - LangGraph: 높은 유연성을 제공하여 커스텀 로직을 쉽게 구현 가능. 개발자가 원하는 대로 그래프 구조를 설계하고 각 노드의 동작을 상세하게 정의 가능
  - LangChain: 미리 정의된 컴포넌트를 중심으로 구성되어 있어, 기본적인 기능을 빠르게 구현할 수 있지만 고도로 커스터마이즈된 로직을 구현하는 데는 상대적으로 제한이 있을 수 있음
5. 학습 곡선:
  - LangGraph: 그래프 이론과 상태 관리에 대한 이해가 필요하여 상대적으로 가파른 러닝 커브 가짐. 더 복잡하고 정교한 시스템 구축 가능
  - LangChain: 직관적인 API와 풍부한 예제로 인해 상대적으로 완만한 러닝 커브 가짐. 초보자도 빠르게 기본적인 LLM 애플리케이션을 만들 수 있음.
6. 용도
  - LangGraph: 복잡한 AI 시스템이나 다중 에이전트 시스템을 구축하는 데 적합. 여러 AI 모델이 상호작용하거나 복잡한 의사결정 과정이 필요한 프로젝트에 이상적임
  - LangChain: 간단한 LLM 애플리케이션이나 RAG(Retrieval-Augmented Generation) 시스템을 구축하는 데 주로 사용. 빠른 개발과 프로토타이핑이 필요한 프로젝트에 적합


출처

- [랭체인(LangChain)이란 무엇인가?](https://www.samsungsds.com/kr/insights/what-is-langchain.html)
- [LangChain이란 무엇인가요?](https://www.ibm.com/kr-ko/think/topics/langchain)
- [LangGraph 가이드북](https://wikidocs.net/261585)
