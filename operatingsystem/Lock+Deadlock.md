# Lock
> 데이터의 일관성을 보장하기 위한 방법 
- 동시성을 제어하기 위한 기능 

## Lock의 종류 
### Shared Lock (S)
- Read Lock
- 데이터를 변경하지 않는 `읽기` 명령에 주어지는 Lock 
- 여러 트랜잭션에서 동시에 하나의 데이터를 읽을 수 있다. (Shared Lock을 동시에 여러 개 걸 수 있다.)
- 공유 락이 설정되어 있는 동안에는 다른 트랜잭션이 데이터를 변경할 수 없다.
- 다른 배타적 잠금을 허용하지 않으며 호환되지 않는다. (어떤 자원에 Shared Lock이 하나라도 걸려 있으면 Exclusive Lock을 걸 수 없다.)

### Exclusive Lock (X) 
- Write Lock
- 데이터에 변경을 가하는 `쓰기` 명령들에 대해 주어지는 Lock
- 어떤 트랜잭션에서 데이터를 변경하고자 할 때 해당 트랜잭션이 완료될 때까지 해당 테이블 혹은 레코드를 다른 트랜잭션에서 읽거나 쓰지 못하게 하기 위해 락을 걸고 트랜잭션을 진행시킨다.
- Exclusive Lock에 걸리면 Shared Lock을 걸 수 없다.
- Exclusive Lock에 걸린 테이블, 레코드 등의 자원에 대해 다른 트랜잭션이 Exclusive Lock을 걸 수 없다.

### Update Lock (U)
- 수정 시에 배타적 락을 걸기 전 리소스를 읽기 위해 거는 락 
- Dead Lock을 방지하기 위해 사용되는 LOCK
- 공유 락과 호환된다.
- 트랜잭션이 리소스를 수정하면 업데이트 잡금이 배타적 락으로 변환되고 그렇지 않으면 잠금이 공유 락으로 변환된다.
- 일반적으로 `UPDATE` 쿼리의 필터 (`WHERE`) 가 실행되는 과정에서 적용된다.
- 업데이트 락을 하더라도 교착상태를 완전히 방지할 수는 없다. 

# Deadlock (교착상태)
> DB에서 교착상태란, 여러 개의 트랜잭션들이 실행을 하지 못하고 서로 무한정 기다리는 상태를 의미
- 두 개 이상의 process들이 끝없이 이벤트를 기다리고 있는 상황
- 그 이벤트는 기다리고 있는 process만이 발생 시킬 수 있는 것
- 두 트랜잭션이 각각 LOCK을 설정하고 다음 서로의 LOCK에 접근하여 값을 얻어오려고 할 때 이미 각각의 트랜잭션에 의해 LOCK이 설정되어 있기 때문에 양쪽 트랜잭션 모두 영원히 처리가 되지 않게 되는 상태

## 교착상태 발생의 필요 충분 조건
- 상호 배제 (Mutual Exclusion) : 한 번에 한 개의 프로세스만이 공유 자원을 사용할 수 있어야 한다.
- 점유와 대기 (Hold and Wait) : 최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용되고 있는 자원을 추가로 점유하기 위해 대기하는 프로세서가 있어야 한다.
- 비선점 (Non-preemption) : 다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없어야 한다.
- 환형 대기 (Circular Wait) : 공유 자원과 공유 자원을 사용하기 위해 대기하는 프로세스들이 원형으로 구성되어 있어 자신에게 할당된 자원을 점유하면서 앞이나 뒤에 있는 프로세스의 자원을 요구해야 한다.

## 교착상태의 해결 방법
### 예방 기법 (Prevention)
- 교착상태가 발생하지 않도록 사전에 시스템을 제어하는 방법
- 교착상태 발생의 제 가지 조건 중에서 어느 하나를 제거(부정)함으로써 수행
- 자원의 낭비가 가장 심한 기법
- 자원의 상호 배제 조건 방지 : 한 번에 여러 프로세스가 공유 자원을 사용할 수 있게 한다. -> 추후 동기화 관련 문제 발생 가능성 있음.
- 점유 대기 조건 방지 : 프로세스 실행에 필요한 모든 자원을 한꺼번에 요구하고 허용할 때까지 작업을 보류해서, 나중에 또 다른 자원을 점유하기 위한 대기 조건을 성립하지 않도록 한다.
- 비선점 조건 방지 : 이미 다른 프로세스에게 할당된 자원이 선점권이 없다고 가정할 때, 높은 우선순위의 프로세스가 해당 자원을 선점할 수 있도록 한다.
- 순환 대기 조건 방지 : 자원을 순환 형태로 대기하지 않도록 일정한 한쪽 방향으로만 자원을 요구할 수 있도록 한다.

### 회피 기법 (Avoidance)
- 교착상태가 발생할 가능성을 배제하지 않고 교착상태가 발생하면 적절히 피해나가는 방법
- 은행원 알고리즘 (Banker's Algorithm)이 주로 사용됨
    - 은행에서 모든 고객의 요구가 충족되도록 현금을 할당하는 데서 유래한 기법 
    - 미리 결정된 모든 자원들의 최대 가능한 할당량을 가지고 시뮬레이션 해서 SAFE STATE에 들 수 있는 지 여부 조사. 미리 교착 상태 가능성 조사.
- Safe Sequence
  - 특정한 순서로 프로세스들에게 자원을 할당, 실행 및 종료 등의 작업을 할 때 데드락이 발생하지 않는 순서를 찾을 수 있을 경우 
- 자원을 할당한 후에도 시스템이 항상 SAFE STATE에 있을 수 있도록 할당을 허용하자는 것  

### 발견 기법 (Detection)
- 시스템에 교착상태가 발생했는지 점검하여 교착상태에 있는 프로세스와 자원을 발견하는 것
- 교착상태 발견 알고리즘(Allocation, Request, Available)과 자원 할당 그래프 등 사용 가능

### 회복 기법 (Recovery)
- 교착상태를 일으킨 프로세스를 종료하거나 교착상태의 프로세스에 할당된 자원을 선점하여 프로세스나 자원을 회복하는 것
- 단순히 프로세스 1개 이상 중단시키기
  - 교착 상태에 빠진 모든 프로세스 중단하기 : 부분 결과가 폐기될 수 있는 부작용
  - 프로세스를 하나씩 중단 시킬 때마다 발견 알고리즘으로 데드락을 탐지하면서 회복시키는 방법 : 부담이 되는 작업.
- 자원 선점하기 
  - 프로세스에 할당된 자원을 선점해서 교착 상태를 해결할 때까지 그 자원을 다른 프로세스에 할당해주는 방법

## 데이터베이스 Deadlock 최소화 
### 트랜잭션
- 트랜잭션 진행방향을 같은 방향으로 처리 (동일한 테이블 순으로 접근)
- 트랜잭션 처리 속도 최소화 -> 자주 커밋
- Wait-die와 Wound-Wait
  - Wait-die : 다른 트랜잭션이 데이터를 점유하고 있을 때 기다리거나 포기하는 방식. 오래된 프로세스에게 대기의 기회를 제공하고, 최신 프로세스는 자주 복귀함(접근 포기)으로써 오버헤드의 가능성이 있다.
  - Wound-Wait : 다른 트랜잭션이 데이터를 점유하고 있을 때 빼앗거나 기다리는 방식. 오래된 프로세스에게 선점의 기회를 제공하고, 최신 프로세스는 대기함에 따라 복귀를 최소화한다.

### DBMS
- 인덱스 설정
- 테이블 정규화
- Isolation Level 조정
- Lock Timeout 설정 
  - SET LOCK_TIMEOUT문을 이용하여 잠금해제 시간 조절
- 프로시저 우선순위 설정   

참고 자료 : 정보처리기사 필기 자료, https://velog.io/@koo8624/Database-데이터베이스-락Lock의-종류와-역할, https://jeong-pro.tistory.com/94, https://sabarada.tistory.com/121, https://chanhuiseok.github.io/posts/cs-2/, https://sosopro.tistory.com/55