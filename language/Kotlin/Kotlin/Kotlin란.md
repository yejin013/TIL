# Kotlin

> 코틀린의 목적 : 자바가 사용되고 있는 모든 용도에 적합하면서도 더 간결하고 생산적이며 안전한 대체 언어 제공 

~~코틀린을 사용한 이유, 자바보다 간결하고 배우기 쉬우며 자바와 혼용하기 쉽고 null 처리 등 코틀린의 장점을 직접 느껴보고, 앞으로 코틀린을 사용할 전망이 높다는 것을 보고 공부하게 되었습니다~~

## 코틀린의 시작
- Jetbrains에서 개발한 언어로, 2011년에 발표되었다.
- 2017년 구글에서 안드로이드 공식 언어로 선택하였다.

## 코틀린 주 활용 영역
- 웹 애플리케이션의 백엔드
- 안드로이드 디바이스 기반의 모바일 애플리케이션

## 코틀린의 특징
- 자바와의 호환성
  - 자바 메소드 호출, 자바 클래스 상속, 인터페이스 구현, 자바 어노테이션 등 자바에서 적용하던 것을 모두 코틀린에서 할 수 있다.
  - 기존 자바 라이브러리를 사용할 수 있다.
  - 자바 표준 라이브러리 클래스에 의존한다.
  - 자바의 기존 프로그래밍 스타일을 코틀린에 적용할 수 있다.
  
- 간걸성
  - getter, setter, 생성자 등 코드를 코틀린에서 묵시적으로 제공한다.
  - 함수형 프로그래밍 기법 (람다) 을 사용할 수 있다.
    - 작은 코드 블록을 라이브러리 함수에 쉽게 전달하여 코드의 양이 줄어들고, 가독성이 좋아진다.
  
- 안전성
  - JVM에서 실행하기 때문
  - 런타임 오버헤드가 거의 없다.
  - 널 타입을 지원한다. 코틀린의 변수는 Nullable과 NotNull로 나누어져 있다. NullPointerException으로 인한 프로그램 오류를 방지한다.
    - 널 값 허용 여부를 컴파일 단계에서 검사하여 널 포인터로 인한 프로그램 중단을 예방할 수 있다.
    ```
    val s: String? = null // 널이 될 수 있음 
    var s2: String = "" // 널이 될 수 없음
    ```
    ```
    /* 프로젝트 하면서 실제 구현한 코드 */
    val admin = adminRepository.findByIdAndDeletedAtIsNull(adminId) ?: throw AdminNotFoundException() // null 값을 허용하여, null 값일 경우 에러 처리 
    ```
  
  - 정적 타입 지정언어로, 타입 자동 추론을 사용하여 타입 안정성을 보장한다.
    - 모든 프로그램의 구성요소를 컴파일 시점에 알 수 있고, 컴파일러가 타입을 검증한다.
    - 개발자가 타입을 선언하지 않아도 된다 (Java와의 차이점)
    - 실행 시점에 어떤 메소드를 호출할지 알아내는 과정이 필요 없기 때문에 메소드 호출이 더 빠르다.
    - 개발자가 아니라 컴파일러가 프로그램의 정확성을 검증하기 때문에 실행 시 프로그램이 오류로 중단될 가능성이 적어진다.
    - 코드에서 다루는 객체가 어떤 타입에 속하는지 알 수 있어, 처음 보는 코드를 다룰 때도 더 쉽다. (유지 보수성)
    ```
    var x = 1
    ```
  
  - ClassCastException을 방지한다.
    - 타입 검사와 캐스트가 한 연산자에 의해 이루어져, 타입 검사를 생략하는 것을 줄일 수 있다.
    ```
    if (value is String) println(value.toUppserCase())
    ```


- 함수 타입 지원
  - 함수형 프로그래밍을 지원한다.
  - 가독성을 높이고 유지보수를 용이하게 만든다.
  - 함수를 통해 불변 데이터 구조를 사용하기 때문에 다중 스레드를 사용해도 안정적이다.
  
  ```
  /* 프로젝트 하면서 실제 구현한 코드 */
  adminRepository.findByIdOrNull(dto.id)?.let { throw AdminIdAlreadyExistException() }
  ```
  
